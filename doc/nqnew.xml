<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd">

<Book Name="nq">                                        <!-- REQUIRED -->

  <!--
                          The title page
                                                                      -->
  <TitlePage>                                           <!-- REQUIRED -->
    <Title>                                             <!-- REQUIRED -->
        <Package>NQ</Package>
    </Title>
    <Subtitle>                                          <!-- OPTIONAL -->
        A &GAP; 4 Package<Br></Br>
        computing nilpotent factor groups of finitely
        presented groups<Br></Br>
        &nbsp;<Br></Br>
        Based on the Standalone ANU Nilpotent Quotient Package
    </Subtitle>
    <Version>Version 2.0</Version>                      <!-- OPTIONAL -->
    <Author>
        Werner Nickel<Br></Br>                          <!-- REQUIRED -->
        &nbsp;
        <Address>
            Fachbereich Mathematik, AG 2<Br></Br>
            TU Darmstadt<Br></Br>
            Schlossgartenstr. 7<Br></Br>
            64289 Darmstadt<Br></Br>
            Germany
        </Address>
        <Email>
            nickel@mathematik.tu-darmstadt.de
        </Email>
        <Homepage>www.mathematik.tu-darmstadt.de/~nickel</Homepage>
    </Author>
    <Date>October 2002</Date>                           <!-- OPTIONAL -->
    <Abstract>                                          <!-- OPTIONAL -->
        This package takes as input a finitely presented group
        together with a positive integer <M>c</M>.  It computes a
        polycyclic presentation for the largest nilpotent factor group
        of class at most <M>c</M>.
    </Abstract> 
    <Copyright>                                         <!-- OPTIONAL -->
        &copyright; 1992-2002 Werner Nickel.
    </Copyright>
    <Acknowledgements> <!-- OPTIONAL --> 
    The development of this program was started while the
    author was supported by an Australian National University PhD
    scholarship and an Overseas Postgraduate Research Scholarship.

    <P/>Further development of this program was done with support from the
    DFG-Schwerpunkt-Projekt "`Algorithmische Zahlentheorie und
    Algebra"'.

    <P/>Over the years a number of people have made useful suggestions
    that found their way into the code:  Mike Newman, Michael
    Vaughan-Lee, Joachim Neubüser, Charles Sims.

    <P/>I thank Volkmar Felsch and Joachim Neubüser for their careful
    examination of the package prior to its release for GAP 4.

    <P/>This documentation was prepared with the <Package>GAPDoc</Package>
    package by Frank Lübeck and Max Neunhöffer.
    </Acknowledgements>
    </TitlePage>



  <TableOfContents/>                                    <!-- OPTIONAL -->



  <!--
                            The document
                                                                      -->
  <Body>                                                <!-- REQUIRED -->

  <Chapter>
  <Heading>Introduction</Heading>

  This package provides an interface between &GAP; 4 and the
  Australian National University Nilpotent Quotient Program (ANU NQ).
  The ANU NQ was implemented as part of the author's work towards his
  PhD at the Australian National University, hence the name of the
  program.  The program takes as input a finite presentation of a
  group and successively computes factor groups modulo the terms of
  the lower central series of the group.  These factor groups are
  computed in terms of a polycyclic presentation.

  <P/> The ANU NQ is implemented  in  the programming language  C. The
  implementation has been developed in  a Unix environment and Unix is
  currently the only operating system  supported.  It runs on a number
  of different Unix versions, e.g.  Solaris and Linux.

  <P/> For integer matrix computations it relies on the GNU MP package
  and requires this package to be installed on your system.  
  
  <P/> This package relies  on the functionality for polycyclic groups
  provided  by the  &GAP; package  <Package>polycyclic</Package> <Cite
  Key="polycyclic"/>       and        requires       the       package
  <Package>polycyclic</Package> to be installed  as a &GAP; package on
  your computer system.

  <P/>
  Comments,  bug reports and  suggestions are  very welcome.

  </Chapter>

  <Chapter><Heading>General remarks</Heading>

  In this chapter we define notation used throughout this manual and
  recollect basic facts about nilpotent groups.  We also provide some
  background information about the functionality implemented in this
  package. 


  <Section><Heading>Commutators and the Lower Central Series</Heading>

  <Index>commutator</Index> The <E>commutator</E> of two elements
  <M>h_1</M> and <M>h_2</M> of a group <M>G</M> is the element
  <M>h_1^{-1}h_2^{-1}h_1h_2</M> and is denoted by <M>[h_1,h_2]</M>.
  It satisfies the equation <M>h_1h_2 = h_2h_1[h_1,h_2]</M> and
  can be interpreted as the correction term that has to be introduced
  into a word if two elements of a group are interchanged.
  Iterated commutators are written in <E>left-normed fashion</E>:
  <Index>left-normed commutator</Index>
  <M>[h_1,h_2,\ldots,h_{n-1},h_n]=[[h_1,h_2,\ldots,h_{n-1}],h_n]</M>.

  <P/> 
  <Index>lower central series</Index>
  The <E>lower central series</E> of <M>G</M> is defined inductively
  as <M>G_1 = G, G_i = [G_{i-1},G]</M> for <M>i \ge 2</M>.
  Each term in the lower central
  series is a normal (even fully invariant) subgroup of <M>G</M>.
  The factors of the lower central series are abelian groups.  On each
  factor the induced action of <M>G</M> via conjugation is the trivial
  action.  

  <P/>The factor <M>G_k/G_{k+1}</M> is generated by the
  elements <M>[g,h]G_{k+1},</M> where <M>g</M> runs through a set of
  (representatives of) generators for <M>G/G_2</M> and <M>h</M> runs
  through a set of (representatives of) generators for
  <M>G_{k-1}/G_k.</M> Therefore, each factor of the lower central
  series is finitely generated if <M>G</M> is finitely generated.

  <P/> If one factor of the lower central series is finite, then all
  subsequent factors are finite.  Then the exponent of the
  <M>k+1</M>-th factor is a divisor of the exponent of the <M>k</M>-th
  factor of the lower central series.  In particular, the exponents of
  all factors of the lower central series are bounded by the
  exponent of the first finite factor of the lower central series.
  </Section>

  <Section><Heading>Nilpotent groups</Heading>

  <Index>nilpotent</Index>
  A group <M>G</M> is called <E>nilpotent</E> if there is a positive
  integer <M>c</M> such that all <M>(c+1)</M>-fold commutators are
  trivial in <M>G.</M> The smallest integer with this property is
  called the 
  <Index>nilpotency class</Index><Index>class</Index>
  <E>nilpotency class</E> of <M>G</M>.  In terms of the lower
  central series a group <M>G \not= 1</M> has nilpotency class <M>c</M>
  if and only if
  <M>G_{c} \not= 1</M> and <M>G_{c+1} = 1</M>.

  <P/>Examples of nilpotent groups are finite <M>p</M>-groups, the
  group of unitriangular matrices over a ring with one and the factor
  groups of a free group modulo the terms of its lower central
  series.  

  <P/>Finiteness of a nilpotent group can be decided by the group's
  commutator factor group.  A nilpotent group is finite if and only if
  its commutator factor group is finite.  A group whose commutator
  factor group is finite can only have finite nilpotent quotient
  groups.

  <P/> By refining the lower central series of a finitely generated
  nilpotent group one can obtain a (sub)normal series
  <M>G_1&gt;G_2&gt;...&gt;G_{k+1}=1</M> with cyclic (central) factors.
  Therefore, every finitely generated nilpotent group is
  <Index>polycyclic</Index><E>polycyclic</E>.  Such a <E>polycyclic
  series</E> gives rise to a <Index>polycyclic generating
  sequence</Index> polycyclic generating sequence by choosing a
  generator <M>a_i</M> for each cyclic factor <M>G_i/G_{i+1}</M>.
  Let <M>I</M> be the
  set of indices such that <M>G_i/G_{i+1}</M> is finite.  A simple
  induction argument shows that every element of the group can be
  written uniquely as a <E>normal word</E> <M>a_1^{e_1}\ldots
  a_n^{e_n}</M> with integers <M>e_i</M> and <M>0\leq e_i&lt;m_i</M>
  for <M>i\in I</M>.

  </Section>
  
  <Section><Heading>Nilpotent presentations </Heading>

  <P/>From a polycyclic generating sequence one can obtain a
  <Index>polycyclic presentation</Index> <E>polycyclic
  presentation</E> for the group.  The following set of power and
  commutator relations is a defining set of relations.  The
  <Index>power relation</Index> <E>power relations</E> express
  <M>a_i^{m_i}</M> in terms of the generators
  <M>a_{i+1},\ldots,a_n</M> whenever <M>G_i/G_{i+1}</M> is finite with
  order <M>m_i</M>. The <Index>commutator relation</Index>
  <E>commutator relations</E> are obtained by expressing
  <M>[a_j,a_i]</M> for <M>j&gt;i</M> as a word in the generators
  <M>a_{i+1},\ldots,a_n</M>.  If the polycyclic series is obtained
  from refining the lower central series, then <M>[a_j,a_i]</M> is
  even a word in <M>a_{j+1},\ldots,a_n</M>.  In this case we obtain a
  nilpotent presentation.

  <P/>To be more precise, a <Index>nilpotent presentation</Index>
  <E>nilpotent presentation</E> is given on a finite number of
  generators <M>a_1,\ldots,a_n</M>.  Let <M>I</M> be the set of
  indices such that <M>G_i/G_{i+1}</M> is finite.  Let <M>m_i</M> be
  the order of <M>G_i/G_{i+1}</M> for <M>i\in I</M>.  Then a nilpotent
  presentation has the form
  <Display>
  \langle a,\ldots,a_n | 
      a_i^{m_i}   = w_{ii}(a_{i+1},\ldots,a_n) 
                 \mbox{ for } i\in I;\; 
      [a_j,a_i] = w_{ij}(a_{j+1},\ldots,a_n)
                 \mbox{ for } 1\leq i &lt; j\leq n\rangle
  </Display>
  Here, <M>w_{ij}(a_k,\ldots,a_n)</M> denotes a group word in the
  generators <M>a_k,\ldots,a_n</M>. 

  <P/>In a group given by a polycyclic presentation each element in
  the group can be written as a <E>normal word</E> <M>a_1^{e_1}\ldots
  a_n^{e_n}</M> with <M>e_i \in \Z</M> and <M>0 \leq e_i &lt; m_i</M>
  for <M>i \in I</M>.  A procedure called <E>collection</E> can be
  used to convert an arbitrary word in the generators into an
  equivalent normal word.  In general, the resulting normal word need
  not be unique.  The result of collecting a word may depend on the
  steps chosen during the collection procedure.  A polycyclic
  presentation with the property that two different normal words are
  never equivalent is called
  <E>consistent</E><Index>consistent</Index>.  A polycyclic
  presentation derived from a polycyclic series as above is
  consistent.  The following example shows an inconsistent polycyclic
  presentation

  <Display>\langle a,b\mid a^2, b^a = b^2 \rangle </Display> 

  as <M>b = baa = ab^2a = a^2b^4 = b^4</M> which implies <M>b^3=1</M>.
  Here we have the equivalent normal words <M>b^3</M> and the empty
  word.  It can be proved that consistency can be checked by
  collecting a finite number of words in the given generating set in
  two essentially different ways and checking if the resulting normal
  forms are the same in both cases.  See Chapter 9 of the book <Cite
  Key="Sims94"/> for an introduction to polycyclic groups and
  polycyclic presentations.

  <P/>For computations in a polycyclic group one chooses a consistent
  polycyclic presentation as it offers a simple solution to the word
  problem: Equality between two words is decided by collecting both
  words to their respective normal forms and comparing the normal
  forms.  Nilpotent groups and nilpotent presentations are special
  cases of polycyclic groups and polycyclic presentations.  Nilpotent
  presentations allow specially efficient collection methods.  The
  package <Package>Polycyclic</Package> provides algorithms to compute
  with polycyclic groups given by a polycyclic presentation.

  <P/>However, inconsistent nilpotent presentations arise naturally in
  the nilpotent quotient algorithm.  There is an algorithm based on
  the test words for consistency mentioned above to modify the arising
  inconsistent presentations suitably to obtain a consistent one for
  the same group.
  </Section>

  <Section><Heading>A sketch of the algorithm</Heading>

  The input for the ANU NQ in its simplest form is a finite
  presentation <M>\langle X|R\rangle</M> for a group <M>G</M>.  The
  first step of the algorithm determines a nilpotent presentation for
  the commutator quotient of <M>G</M>.  This is a presentation of the
  class-<M>1</M> quotient of <M>G</M>.  Call its generators
  <M>a_1,...,a_d</M>.  It also determines a homomorphism of <M>G</M>
  onto the commutator quotient and describes it by specifying the
  image of each generator in <M>X</M> as a word in the <M>a_i</M>.

  <P/>For the general step assume that the algorithm has computed a
  nilpotent presentation for the class-<M>c</M> quotient of <M>G</M>
  and that <M>a_1,...,a_d</M> are the generators introduced in the
  first step of the algorithm.  Furthermore, there is a map from X
  into the class-<M>c</M> quotient describing the epimorphism from
  <M>G</M> onto <M>G/G_{c+1}</M>.

  <P/>Let <M>b_1,...b_k</M> be the generators from the last step of
  the algorithm, the computation of <M>G_c/G_{c+1}</M>.  This means
  that <M>b_1,...b_k</M> generate <M>G_c/G_{c+1}</M>.  Then the
  commutators <M>[b_j,a_i]</M> generate <M>G_{c+1}/G_{c+2}</M>.  The
  algorithm introduces new, central generators <M>c_{ij}</M> into the
  presentation, adds the relations <M>[b_j,a_i] = c_{ij}</M> and
  modifies the existing relations by appending suitable words in the
  <M>c_{ij}</M>, called <E>tails</E>, to the right hand sides of the
  power and commutator relations.  The resulting presentation is a
  nilpotent presentation for the <E>nilpotent cover</E> of
  <M>G/G_{c+1}</M>.  The nilpotent cover is the largest central
  extension of <M>G/G_{c+1}</M> generated by <M>d</M>
  elements.  It is is uniquely determined up to isomorphism.
  
  <P/>The resulting presentation of the nilpotent cover is in general
  inconsistent.  Consistency is achieved by running the consistency
  test.  This results in relations among the generators
  <M>c_{ij}</M> which can be used to eliminate some of those
  generators or introduce power relations.  After this has been done
  we have a consistent nilpotent presentation for the nilpotent cover
  of <M>G/G_{c+1}</M>.
  
  <P/>Furthermore, the nilpotent cover need not satisfy the relations
  of <M>G</M>.  In other words, the epimorphism from <M>G</M> onto
  <M>G/G_{c+1}</M> cannot be lifted to an epimorphism onto the
  nilpotent cover.  Applying the epimorphism to each relation of
  <M>G</M> and collecting the resulting words of the nilpotent cover
  yields a set of words in the <M>c_{ij}</M>.  This gives further
  relations between the <M>c_{ij}</M> which leads to further
  eliminations or modifications of the power relations for the
  <M>c_{ij}</M>.

  <P/>After this, the inductive step of the ANU NQ is complete and a
  consistent nilpotent presentation for <M>G/G_{c+2}</M> is obtained
  together with an epimorphism from <M>G</M> onto the
  class-<M>(c+1)</M> quotient.

  <P/>Chapter 11 of the book <Cite Key="Sims94"/> discusses a
  nilpotent quotient algorithm.  A description of the implementation
  in the ANU NQ is contained in <Cite Key="Nickel96"/>
  </Section>

  <Section><Heading>Identical Relations</Heading>

  Let <M>w</M> be a word in free generators <M>x_1,\ldots,x_n</M>.  A
  group <M>G</M> satisfies the relation <M>w</M> <E>identically</E> if
  each map from <M>x_1,\ldots,x_n</M> into <M>G</M> maps <M>w</M> to
  the identity.  We also say that <M>G</M> satisfies the
  <Index>identical relation</Index> <Index>law</Index> <E>identical
  relation</E> <M>w</M> or satisfies the <E>law</E> <M>w</M>.  In
  slight abuse of notation, we call the elements <M>x_1,\ldots,x_n</M>
  <Index>identical generator</Index> <Index>law generator</Index>
  identical or law generators.

  <P/> Common examples of identical relations are: A group of
  nilpotency class at most <M>c</M> satisfies the law
  <M>[x_1,\ldots,x_{c+1}]</M>.  A group that satisfies the law
  <M>[x,y,\ldots,y]</M> where <M>y</M> occurs <M>n</M>-times, is
  called an <M>n</M>-Engel group.  A group that satisfies the law
  <M>x^d</M> is a group of exponent <M>d</M>.

  <P/>
  To describe finitely presented groups that satisfy one or more laws,
  we extend a common notation for finitely presented groups 
  by specifying the identical generators as part of the generator
  list, separated from the group generators by a semicolon: For
  example
  <Display>
  \langle a,b,c; x,y | x^5, [x,y,y,y]\rangle
  </Display>
  is a group on 3 generators <M>a,b,c</M> of exponent <M>5</M>
  satisfying the 3rd Engel law.  The presentation above is equivalent
  to a presentation on 3 generators with an infinite set of relations,
  where the set of relations consists of all fifth powers of words in
  the generators and all commutators <M>[x,y,y,y]</M> where <M>x</M>
  and <M>y</M> run through all words in the generators <M>a,b,c</M>.
  The standalone programme accepts this notation as a description of
  its input.  In <Package>GAP 4</Package> finitely presented groups
  are specified in a different way, see <Ref Func="NilpotentQuotient"
  Style="Text"/> for a description.

  <P/>
  This notation can also be used in words that mix group and identical
  generators as in the following example:
  <Display>
  \langle a,b,c; x | [x,c], [a,x,x,x] \rangle
  </Display>
  The first relation says that <M>c</M> commutes with all elements of
  the group.  The second relation turns <M>a</M> into a third right
  Engel element.

  </Section>

  <Section Label="ExpTrees"><Heading>Expression trees</Heading>
  Expressions involving commutators play an important role in the
  context of nilpotent groups.  Expanding an iterated commutator
  produces a complicated and long expression.  For example, 
  <Display>
            [x,y,z] = y^{-1}x^{-1}yxz^{-1}x^{-1}y^{-1}xyz.
  </Display>
  Evaluating a commutator <M>[a,b]</M> is done efficiently by
  computing the equation <M>(ba)^{-1}ab</M>.  Therefore, for each
  commutator we need to perform two multiplications and one inversion.
  Evaluating <M>[x,y,z]</M> needs four multiplications and two
  inversions.  Evaluation of an iterated commutator with <M>n</M>
  components takes <M>2n-1</M> multiplications and
  <M>n-1</M> inversions.  The expression on the right hand side above
  needs <M>9</M> multiplications and <M>5</M> inversions which is
  clearly much more expensive than evaluating the commutator directly.  

  <P/> Assuming that no cancellations occur, expanding an iterated
  commutator with n components produces a word with
  <M>2^{n+1}-2^{n-1}-2</M> factors half of which are inverses.  A
  similar effect occurs whenever a compact expression is expanded into
  a word in generators and inverses, for example <M>(ab)^{49}</M>.

  <P/> Therefore, it is important not to expand expressions into a
  word in generators and inverses.  For this purpose we provide a
  mechanism which we call here 
  <Index>expression trees</Index>
  <E>expression trees</E>.  An expression tree preserves the
  structure of a given expression.  It is a (binary) tree in which
  each node is assigned an operation and whose leaves are generators
  of a free group or integers.  For example, the expression
  <M>[(xy)^2, z]</M> is stored as a tree whose top node is a
  commutator node.  The right subtree is just a generator node
  (corresponding to <M>z</M>).  The
  left subtree is a power node whose subtrees are a
  product node on the left and an integer node on the right.  An
  expression tree can involve products, powers, conjugates and
  commutators.  However, the list of available operations can
  be extended.

  <P/>Evaluation of an expression tree is done recursively and
  requires as many operations as there are nodes in the tree.

  <P/>A presentation specified by expression trees is a record with
  the components <F>.generators</F> and <F>.relations</F>.
  <Example>
gap> RequirePackage( "nq" );
true
gap> gens := ExpressionTrees( 2 );
[ x1, x2 ]
gap> r1 := LeftNormedComm( [gens[1],gens[2],gens[2]] );
[ x1, x2, x2 ]
gap> r2 := LeftNormedComm( [gens[1],gens[2],gens[2],gens[1]] );
[ x1, x2, x2, x1 ]
gap> pres := rec( generators := gens, relations := [r1,r2] );
rec( generators := [ x1, x2 ], 
  relations := [ [ x1, x2, x2 ], [ x1, x2, x2, x1 ] ] )
  </Example>
  </Section>

  <Section><Heading>A word about the implementation</Heading>

  The ANU NQ is written in C, but not in ANSI C.  I hope to make one
  of the next versions ANSI compliable.  However, it uses a fairly
  restricted subset of the language so that it should be easy to
  compile it in new environments.  The code is 64-bit clean.  If you
  have difficulties with porting it to a new environment, let me know
  and I'll be hapy to assist if time permits.

  <P/>The program has two collectors:  a simple collector from the left
  as described in <Cite Key="LS90"/> and a combinatorial from the left
  collector as described in <Cite Key="VL90a"/>.  The combinatorial
  collector is always faster than the simple collector, therefore, it
  is the collector used by this package by default.  This can be
  changed by modifying the global variable <Ref Var="NqDefaultOptions"
  Style="Text"/>.

  <P/>In a polycyclic group with generators that do not have power
  relations, exponents may become arbitrarily large.  Experience shows
  that this happens rarely in the computations done by the ANU NQ.
  Exponents are represented by 32-bit integers.  The collectors
  perform an overflow check and abort the computation if an overflow
  occurred.  In a GNU environment the program can be compiled using
  the `long long' 64-bit integer type.  For this uncomment the
  relevant line in src/Makefile and recompile the program.

  <P/>As part of the step that enforces consistency and the relations
  of the group, the ANU NQ performs computations with integer matrices
  and converts them to Hermite Normal Form.  The algorithm used here
  is a variation of the Kanan-Bachem algorithm based on the GNU
  multiple precision package GNU MP (reference!!!).  Experience shows
  that the integer matrices are usually fairly sparse and Kanan-Bachem
  seems to be sufficient in this context.  However, the implementation
  might benefit from a more efficient strategy for computing Hermite
  Normal Forms.  This is a topic for further investigations.

  <P/>As the program does not compute the Smith Normal Form for each 
  factor of the lower central series but the Hermite Normal
  Form, it does not necessarily obtain a minimal generating set for
  each factor of the lower central series.  The following is a simple
  example of this behaviour.  We take the presentation
  <Display>
  \langle x, y | x^2 = y \rangle
  </Display>
  The group is clearly isomorphic to the additive group of the
  integers.  Applying the ANU NQ to this presnetation gives the
  follwoing nilpotent presnetation:
  <Display>
    \langle A,B | A^2 = B, [B,A] \rangle
  </Display>
  A nilpotent presentation on a minimal generating set would be the
  presentation of the free group on one generator:
  <Display>
    \langle A | \; \rangle
  </Display>

  </Section>

  </Chapter>  

  <Chapter>
  <Heading>The Functions of the Package</Heading>
  <Index>Nilpotent Quotient Package</Index>

     <Section><Heading>Nilpotent Quotients of Finitely Presented Groups</Heading>

        <ManSection>
        <Func Name="NilpotentQuotient" 
              Arg="[output-file,] fp-group [, id-gens] [, c]"/>
        <Func Name="NilpotentQuotient" 
              Arg="[output-file,] input-file [, c]"/>
        <Description>
           The   parameter  <F>fp-group</F>   is  either   a  finitely
           presented group  or a  record specifying a  presentation by
           expression trees (see section <Ref Sect="ExpTrees"/>).  The
           parameter <F>input-file</F> is a string specifying the name
           of  a file containing  a finite  presentation in  the input
           format of the ANU NQ.  Let <M>G</M> be the group defined by
           <F>fp-group</F> or the group defined in <F>input-file</F>.

           <P/>  The function  computes a  nilpotent  presentation for
           <M>G/G_{c+1}</M>  if  the  optional parameter  <F>c</F>  is
           specified.   If <F>c</F>  is not  given, then  the function
           attempts  to  compute  the  largest nilpotent  quotient  of
           <M>G</M>  and it  will  terminate only  if  <M>G</M> has  a
           largest nilpotent quotient.

           <P/>  The optional  argument  <F>id-gens</F> is  a list  of
           generators  of  the  free  group  underlying  the  finitely
           presented  group <F>fp-group</F>.   The generators  in this
           list  are treated  as identical  generators.  Consequently,
           all  relations  of   the  <F>fp-group</F>  involving  these
           generators  are treated  as identical  relations  for these
           generators.

           <P/>The following example computes the class-5 quotient of
           the free group on two generators.
<Example>
<![CDATA[
gap> F := FreeGroup( 2 );
<free group on the generators [ f1, f2 ]>
gap> H := NilpotentQuotient( F, 5 );
Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
time: 20 msec
gap> lcs := LowerCentralSeries( H );;
gap> for i in [1..5] do Print( lcs[i] / lcs[i+1], "\n" ); od;
Pcp-group with orders [ 0, 0 ]
Pcp-group with orders [ 0 ]
Pcp-group with orders [ 0, 0 ]
Pcp-group with orders [ 0, 0, 0 ]
Pcp-group with orders [ 0, 0, 0, 0, 0, 0 ]
]]>
</Example>

        Note that the lower central series in the example is part of
        the data returned by the standalone program.  Therefore, the
        execution of the function LowerCentralSeries takes no time.

        <P/>The next example computes the class-4 quotient of the
        infinite dihedral group.  The group is soluble but not
        nilpotent.  The first factor of its lower central series is a
        Klein four group and all the other factors are cyclic or order
        <M>2</M>. 
<Example>
<![CDATA[
gap> F := FreeGroup( 2 );
<free group on the generators [ f1, f2 ]>
gap> G := F / [F.1^2, F.2^2];
<fp group on the generators [ f1, f2 ]>
gap> H := NilpotentQuotient( G, 4 ); 
Pcp-group with orders [ 2, 2, 2, 2, 2 ]
gap> lcs := LowerCentralSeries( H );;
gap> for i in [1..Length(lcs)-1] do
>       Print( AbelianInvariants(lcs[i] / lcs[i+1]), "\n" );
> od;
[ 2, 2 ]
[ 2 ]
[ 2 ]
[ 2 ]
gap> 
]]>
</Example>
In the following example identical generators are used in order to
express that fact that the group is nilpotent of class <M>3</M>.  The
result is the free nilpotent group of class <M>3</M> on two generators.
<Example>
<![CDATA[
gap> F := FreeGroup( "a", "b", "w", "x", "y", "z" );
<free group on the generators [ a, b, w, x, y, z ]>
gap> G := F / [ LeftNormedComm( [F.3,F.4,F.5,F.6] ) ];
<fp group of size infinity on the generators [ a, b, w, x, y, z ]>
gap> H := NilpotentQuotient( G, [F.3,F.4,F.5,F.6] );
Pcp-group with orders [ 0, 0, 0, 0, 0 ]
gap> NilpotencyClassOfGroup(H);
3
gap> LowerCentralSeries(H);
[ Pcp-group with orders [ 0, 0, 0, 0, 0 ], Pcp-group with orders [ 0, 0, 0 ], 
  Pcp-group with orders [ 0, 0 ], Pcp-group with orders [  ] ]
]]>
</Example>
The following example uses expression trees in order to specify the
third Engel law for the free group on <M>3</M> generators.
<Example>
<![CDATA[
gap> et := ExpressionTrees( 5 );                            
[ x1, x2, x3, x4, x5 ]
gap> comm := LeftNormedComm( [et[1], et[2], et[2], et[2]] );
[ x1, x2, x2, x2 ]
gap> G := rec( generators := et, relations := [comm] );
rec( generators := [ x1, x2, x3, x4, x5 ], 
  relations := [ [ x1, x2, x2, x2 ] ] )
gap> H := NilpotentQuotient( G, [et[1],et[2]] );
Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 2, 2, 
  0, 6, 6, 0, 0, 2, 10, 10, 10 ]
gap> TorsionSubgroup( H );
Pcp-group with orders [ 2, 2, 2, 2, 2, 2, 2, 10, 10, 10 ]
gap> lcs := LowerCentralSeries( H );;
gap> NilpotencyClassOfGroup( H );
5
gap> for i in [1..5] do Print( lcs[i] / lcs[i+1], "\n" ); od;
Pcp-group with orders [ 0, 0, 0 ]
Pcp-group with orders [ 0, 0, 0 ]
Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0 ]
Pcp-group with orders [ 2, 4, 2, 2, 0, 6, 6, 0, 0, 2 ]
Pcp-group with orders [ 10, 10, 10 ]
gap> for i in [1..5] do Print( AbelianInvariants(lcs[i]/lcs[i+1]), "\n" ); od;
[ 0, 0, 0 ]
[ 0, 0, 0 ]
[ 0, 0, 0, 0, 0, 0, 0, 0 ]
[ 2, 2, 2, 2, 2, 2, 2, 0, 0, 0 ]
[ 10, 10, 10 ]
]]>
</Example>
The example above also shows that the relative orders of an abelian
polycyclic  group need not be the abelian invariants (elementary
divisors) of the group.  Each zero corresponds to a generator of
infinite order.  The number of zeroes is always correct.
        </Description>
        </ManSection>


        <ManSection>
        <Func Name="NilpotentEngelQuotient" 
              Arg="fp-group, n[, c]"/>
        <Func Name="NilpotentEngelQuotient" 
              Arg="input-file, n[, c]"/>
        <Description>
           This function is a special version of <Ref
           Func="NilpotentQuotient"/> which enforces the <M>n</M>-th
           Engel identity on the nilpotent quotients of the group
           specified by <F>fp-group</F> or by <F>input-file</F>.

<Example>
gap> NilpotentEngelQuotient( FreeGroup(2), 5 );
Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 10, 
  0, 0, 30, 0, 3, 3, 10, 2, 0, 6, 0, 0, 30, 2, 0, 9, 3, 5, 2, 6, 2, 10, 5, 5, 
  2, 0, 3, 3, 3, 3, 3, 5, 5, 3, 3 ]
</Example>

        </Description>
        </ManSection>

        <ManSection>
        <Func Name="NqEpimorphismNilpotentQuotient"
              Arg="[output-file,] fp-group [, id-gens] [, c]"/>
        <Description>
           This function computes an epimorphism from the group
           <M>G</M> given by the finite presentation <F>fp-group</F>
           onto <M>G/G_{c+1}.</M> If <F>c</F> is not given, then the
           largest nilpotent quotient of <M>G</M> is computed and an
           epimorphism from <M>G</M> onto the largest nilpotent
           quotient of <F>G</F>.  If <F>G</F> does not have a largest
           nilpotent quotient, the function will not terminate if
           <F>c</F> is not given.
           
           <P/> The optional argument <F>id-gens</F> is a list of
           generators of the free group underlying the finitely
           presented group <F>fp-group</F>.  The generators in this
           list are treated as identical generators.

        </Description>
        </ManSection>

        <ManSection>
        <Func Name="LowerCentralFactors" 
              Arg="fp-group[, c]"/>
        <Description>        
        This function returns a list containing the abelian invariants
        of the central factors in the lower central series
        of the class-<F>c</F> nilpotent quotient of the finitely
        presented group <F>fp-group</F>.  If <F>c</F> is not given,
        the function attempts to compute the largest nilpotent
        quotient of the group and will not terminate if there is no
        largest nilpotent factor group.
        </Description>
        </ManSection>

     </Section>

     <Section><Heading>Expression Trees</Heading>

     <ManSection>
     <Func Name="ExpressionTrees" Arg="m[, prefix]" />
     <Description>
     The argument <F>m</F> must be a positive integer.  The function
     returns a list with <F>m</F> expression tree symbols named x1,
     x2,...  The optional parameter <F>prefix</F> must be a string and
     is used instead of <F>x</F> if present.

     <P/>     The
     following operations are defined for expression trees:
     multiplication, inversion, exponentiation, forming commutators,
     forming conjugates.
     <Example>
gap> t := ExpressionTrees( 3 );                      
[ x1, x2, x3 ]
gap> tree := Comm( t[1], t[2] )^3/LeftNormedComm( [t[1],t[2],t[3],t[1]] );
[ x1, x2 ]^3/[ x1, x2, x3, x1 ]
     </Example>
     </Description>
     </ManSection>
     <ManSection>
     <Func Name="EvaluateExpTree" Arg="tree, symbols, values" />
     <Description>
     The argument <F>tree</F> is an expression tree followed by the
     list of those symbols <F>symbols</F> from which the expression tree is
     built up.  The argument <F>values</F> is a list containing a
     constant for each symbol.  The function substitutes each value
     for the corresponding symbol and computes the resulting value for
     <F>tree</F>.
     <Example>
<![CDATA[
gap> F := FreeGroup( 3 );                               
<free group on the generators [ f1, f2, f3 ]>
gap> EvaluateExpTree( tree, t, GeneratorsOfGroup(F) );
f1^-1*f2^-1*f1*f2*f1^-1*f2^-1*f1*f2*f1^-1*f2^-1*f1*f2*f1^-1*f3^-1*f2^-1*f1^
-1*f2*f1*f3*f1^-1*f2^-1*f1*f2*f1*f2^-1*f1^-1*f2*f1*f3^-1*f1^-1*f2^-1*f1*f2*f3
]]>
     </Example>
     </Description>
     </ManSection>
  </Section>

  <Section><Heading>Auxiliary Functions</Heading>
     <ManSection>
     <Func Name="NqReadOutput" Arg="stream" />
     <Description>
     The only argument <F>stream</F> is an output stream of the ANU
     NQ.  The function reads the stream and returns a record that has a
     component for each global variable used in the output of the ANU
     NQ, see <Ref Var="NqGlobalVariables" Style="Text"/>.
     </Description>
     </ManSection>
     <ManSection>
     <Func Name="NqStringFpGroup" Arg="fp-group [,idgens]" />
     <Description>
     The function takes a finitely presented group <F>fp-group</F> and
     returns a string in the input format of the ANU NQ.  If the list
     <F>idgens</F> is present, then it must contain generators of the
     free group underlying the finitely presented group (see <Ref
     BookName="ref" Label="FreeGroupOfFpGroup" Style="Text"/>).  The generators in
     <F>idgens</F> are treated as identical generators.
     <Example>
<![CDATA[
gap> F := FreeGroup(2);
<free group on the generators [ f1, f2 ]>
gap> G := F / [F.1^2, F.2^2, (F.1*F.2)^5];
<fp group on the generators [ f1, f2 ]>
gap> NqStringFpGroup( G );
"< x1, x2 |\n    x1^2,\n    x2^2,\n    x1*x2*x1*x2*x1*x2*x1*x2*x1*x2\n>\n"
gap> Print( last );
< x1, x2 |
    x1^2,
    x2^2,
    x1*x2*x1*x2*x1*x2*x1*x2*x1*x2
>
gap> F := FreeGroup(3);
<free group on the generators [ f1, f2, f3 ]>
gap> H := F / [ LeftNormedComm( [F.2,F.1,F.1] ),                               
>               LeftNormedComm( [F.2,F.1,F.2] ), F.3^7 ];
<fp group on the generators [ f1, f2, f3 ]>
gap> NqStringFpGroup( H, [F.3] );                                  
"< x1, x2; x3 |\n    x1^-1*x2^-1*x1*x2*x1^-1*x2^-1*x1^-1*x2*x1^2,\n    x1^-1*x\
2^-1*x1*x2^-1*x1^-1*x2*x1*x2,\n    x3^7\n>\n"
gap> Print( last );
< x1, x2; x3 |
    x1^-1*x2^-1*x1*x2*x1^-1*x2^-1*x1^-1*x2*x1^2,
    x1^-1*x2^-1*x1*x2^-1*x1^-1*x2*x1*x2,
    x3^7
>
]]>
     </Example>
     </Description>
     </ManSection>
     <ManSection>
     <Func Name="NqStringExpTrees" Arg="fp-group [,idgens]" />
     <Description>
     The function takes a finitely presented group <F>fp-group</F>
     given in terms of expression trees and
     returns a string in the input format of the ANU NQ.  If the list
     <F>idgens</F> is present, then it must contain a sublist of the
     generators of the presentation. The generators in <F>idgens</F>
     are treated as identical generators. 
     <Example>
<![CDATA[
gap> x := ExpressionTrees( 2 );
[ x1, x2 ]
gap> rels := [x[1]^2, x[2]^2, (x[1]*x[2])^5]; 
[ x1^2, x2^2, (x1*x2)^5 ]
gap> NqStringExpTrees( rec( generators := x, relations := rels ) );
"< x1, x2 |\n    x1^2,\n    x2^2,\n    (x1*x2)^5\n>\n"
gap> Print( last );         
< x1, x2 |
    x1^2,
    x2^2,
    (x1*x2)^5
>
gap> x := ExpressionTrees( 3 );
[ x1, x2, x3 ]
gap> rels := [LeftNormedComm( [x[2],x[1],x[1]] ),                              
>             LeftNormedComm( [x[2],x[1],x[2]] ), x[3]^7 ];
[ [ x2, x1, x1 ], [ x2, x1, x2 ], x3^7 ]
gap> NqStringExpTrees( rec( generators := x, relations := rels ) );
"< x1, x2, x3 |\n    [ x2, x1, x1 ],\n    [ x2, x1, x2 ],\n    x3^7\n>\n"
gap> Print( last );
< x1, x2, x3 |
    [ x2, x1, x1 ],
    [ x2, x1, x2 ],
    x3^7
>
]]>
     </Example>
     </Description>
     </ManSection>
  </Section>

  <Section><Heading>Global Variables</Heading>
  <ManSection>
  <Var Name="NqRuntime"/>  
     <Description>
     This variable contains the number of milliseconds of runtime of
     the last call of ANU NQ.
     <Example>
gap> NilpotentEngelQuotient( FreeGroup(2), 5 );
Pcp-group with orders [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 10, 
  0, 0, 30, 0, 3, 3, 10, 2, 0, 6, 0, 0, 30, 2, 0, 9, 3, 5, 2, 6, 2, 10, 5, 5, 
  2, 0, 3, 3, 3, 3, 3, 5, 5, 3, 3 ]
gap> NqRuntime;
18200
     </Example>
     </Description>
  </ManSection>
  <ManSection>
  <Var Name="NqDefaultOptions"/>  
     <Description>
     This variable contains a list of strings which are the standard
     command line options passed to the ANU NQ in each call.
     Modifying this variable can be used to pass additional options to
     the ANU NQ.
     <Example>
gap> NqDefaultOptions;
[ "-g", "-p", "-C", "-s" ]
     </Example>
     The option <Arg>-g</Arg> causes the ANU NQ to produce output in
     &GAP;-format.  The option <Arg>-p</Arg> prevents the ANU NQ from
     listing the pc-presentation of the nilpotent quotient at the end
     of the calculation.  The option <Arg>-C</Arg> invokes the
     combinatorial collector.  The option <Arg>-s</Arg> is effective
     only in conjunction with options for computing with Engel
     identities and instructs the ANU NQ to use only semigroup words
     in the generators as instances of an Engel law.
     </Description>
  </ManSection>
  <ManSection>
  <Var Name="NqGlobalVariables"/>  
     <Description>
     This variable is a list of strings with the names of the global
     variables that are used in the output stream of the ANU NQ.  When
     the output stream is read, these global variables are assigned
     new values.  The mechanism provided by 
     <Ref Func="HideGlobalVariables" Style="Text" BookName="Reference" 
     Label="HideGlobalVariables" /> 
     is used to protect these variables from being accidentally
     overwritten. 
     </Description>
  </ManSection>

  </Section>
  </Chapter>

  <Chapter>
  <Heading>Installation of the Package</Heading> The installation of
  the program is easy.  However, it requires the GNU multiple
  precision library (GNU MP).  GNU is the Free Software Foundation's
  collection of UNIX compatible software. If this library is not
  available on your system, it has to be installed first.  A copy of
  GNU MP can be obtained via anonymous ftp from many file servers
  around the world, for example:
  <URL>
        www.gnu-mp.com
  </URL>

  You start compiling NQ by running the configure script
  <Listing> ./configure  </Listing>
  Among other things it will tell you whether it succeeded in locating
  the GNU MP library and the corresponding include files.  If
  configure reports no problems, you proceed by typing
  <Listing> make </Listing>
  If the configure script told you that it could not find the GNU MP
  include files or the GNU MP libraries, you have to run make with
  additional parameters.  For example, if you have installed GNU MP
  yourself in your home directory, you would type something like the
  following
  <Listing> make GNU_MP_INC=/home/me/gmp-2.0.2 GNU_MP_LIB=/home/me/gmp-2.0.2 </Listing>

  <P/>
  A compiled version of the program named `nq' is then placed into the
  directory `bin/&tlt;complicated name&tgt;'.  The &tlt;complicated name&tgt;
  component encodes the operating system and the compiler used.  This
  allows you to compile NQ on several architectures sharing the same
  files system.

  <P/>
  If there are any warnings or even fatal error messages during the
  compilation process, please send a copy to the address at the end of
  this document together with information about your operating system,
  the compiler you used and any changes you might have made to the
  source code.  I will have a look at your problems and try to fix
  them.
 
  <P/>
  <B>Need to update this part</B>

  After the compilation  is finished you   can  check if the ANU  NQ  is
  running properly on your system.  Simply type
  <Listing> make test </Listing>
    The file  runs some computations and compares their output
  with the output files in the directory `examples'.  If testNq
  reports any errors, please follow the instruction that testNq prints
  out.

  </Chapter>

  </Body>

  <Bibliography Databases="nq" />
  <TheIndex/>                                               
</Book>
